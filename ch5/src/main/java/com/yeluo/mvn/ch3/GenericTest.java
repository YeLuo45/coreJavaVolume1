package com.yeluo.mvn.ch3;

import java.util.ArrayList;

/**
 * 
 * @author YeLuo
 * @function 泛型
 */
/*
 * 1.编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从某个方法返回，
 * 编译器会检查这个变量、参数或方法的泛型类型，然后将这个类型放在<>中。在ArrayList<String> sss=new ArrayList<>();
 * 语句中，new ArrayList<>()将赋值至一个类型为ArrayList<String>的变量，所以泛型类型为String
 * 
 * 2.泛型的好处
 * Java 语言中引入泛型是一个较大的功能增强。不仅语言、类型系统和编译器有了较大的变化，以支持泛型，
 * 而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了。
 * 		1.类型安全。 泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，
 * 编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中
 * （或者如果幸运的话，还存在于代码注释中）。
 * 		2.消除强制类型转换。 泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。
 * 		3.潜在的性能收益。 泛型为较大的优化带来可能。在泛型的初始实现中，
 * 编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。
 * 但是更多类型信息可用于编译器这一事实，为未来版本的 JVM 的优化带来可能。
 * 由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改。
 * 所有工作都在编译器中完成，编译器生成类似于没有泛型（和强制类型转换）时所写的代码，只是更能确保类型安全而已。
 * 
 * 3.泛型在使用中还有一些规则和限制
 * 		1、泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。
    	2、同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。
    	3、泛型的类型参数可以有多个。
    	4、泛型的参数类型可以使用extends语句，例如<T extends superclass>。习惯上成为“有界类型”。
    	5、泛型的参数类型还可以是通配符类型。例如Class<?> classType = Class.forName(Java.lang.String);
 */
public class GenericTest {
	public static void main(String[] args) {
		test1();
	}

	/*
	 * “菱形”语法：空尖括号<>就像是一个菱形。
	 */
	private static void test1() {
		ArrayList<String> ss=new ArrayList<String>();
		//Java 7中，可以省略右边的类型参数
		ArrayList<String> sss=new ArrayList<>();
		
	}
}
