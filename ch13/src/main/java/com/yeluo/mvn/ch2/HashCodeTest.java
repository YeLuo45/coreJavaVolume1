package com.yeluo.mvn.ch2;
/**
 * 
 * @author YeLuo
 * @function 散列码(hashCode)
 */
/**
 * 1.问题:在数组或链表中,想要查看某个特定的元素,却又忘记了它的位置,就需要访问所有元素,直到找到为止.
 * 如果集合中包含的元素很多,将会消耗很多时间.
 * 解决:如果不在意元素的顺序,可以有几种能够快速查找元素的数据结构.它们将按照有利于其操作目的的原则组织数据.
 * 缺点:无法控制元素出现的次序.
 * 
 * 2.散列表就是这种可以快速地查找所需要的对象.
 * 散列码:散列表为每个对象计算一个整数
 * 散列码是由对象实例域产生的一个整数.更准确地说,具有不同的数据域的对象将产生不同的散列码.
 * 
 * 3.如果自定义类,就要负责实现这个类的hashCode方法.
 * 注意:自己实现的hashCode方法应该与equals方法兼容(即a.equals(b)为true,a与b必须具有相同的散列码).
 * 
 * 4.在java中散列表用数组实现.每个列表称为桶.要想查找表中的位置,就要先计算它的散列码,然后与桶的总数取余.
 * 或许你会很幸运,在这个桶中没有其他元素,此时将元素直接插入到桶中就可以了.当然,有时候会遇到桶被沾满的情况,
 * 这也是不可避免的.这种现象称为散列冲突.这时,需要用新对象与桶中的所有对象进行比较,查看这个对象是够已经存在.
 * 如果散列码是合理且随机分布的,桶的数目也足够大,需要比较的次数就会很少.
 * 注释:散列冲突越多,运行的性能就越差.
 * 
 * 5.如果大致知道最终要插入多少个元素到散列表中,就可以设置桶数.通常,将桶数设置为预计元素个数的75%~150%.
 * (最好将个数设为素数,以防止键的集聚),标准类库使用的桶数是2的幂,默认值是16.
 * 
 * 6.如果被低估了,导致散列表太满了,就需要在再散列.
 * 如果要对散列表再散列,就需要创建一个桶数更多的表,并将所有元素插入到这个新表中,然后丢弃原来的表.
 * 装填因子(默认是0.75)决定何时对散列表进行再散列.
 * 
 * 7.应用例子:HashSet类和HashMap类
 * 在不在意元素的顺序时使用Hash的类.
 * 
 * 
 */
public class HashCodeTest {

}
