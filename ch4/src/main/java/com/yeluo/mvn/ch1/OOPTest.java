package com.yeluo.mvn.ch1;

import java.util.concurrent.SynchronousQueue;

/**
 * 
 * @author YeLuo
 * @function
 */
 /*
  * 1.面向对象程序设计（简称OOP）是当今主流的程序设计范型
  * 
  * 2.面向对象编程思想：
  * 	1.与具体的语言无关  
  * 	2.与面向过程（倾向于解决的步骤）相对的 
  * 	3.按照人类的自然思维去分析、设计和编码的编码思想
  * 	4.归纳总结--》具有相同特征和行为的一类物体（名词）
  * 
  * 3.程序中很多对象来自标准库，还有一些是自定义的。
  * 究竟是自己构造对象，还是从外界购买对象完全取决于开发项目的预算和时间。
  * 但是，从根本上说，只要对象能够满足要求，就不必关心其功能的具体实现过程。
  * 在OOP中，不必关心对象的具体实现，只要能够满足用户的需求即可。
  * 
  * 4.OOP是将数据放在第一位，然后考虑操作数据的算法。
  * 
  * 5.类是描述具有相同特征和行为的抽象。
  *   对象是描述具体的物体。
  *   实例域/成员变量：对象中的数据。
  *   方法：对象中操作数据的过程。
  *  
  * 6.类的3个基本特征：1.继承 2.封装 3.多态
  * 	1.继承的最主要目的是扩展（实现开闭原则），还有其他的目的：代码重用的重要手段之一。
  * 	子类一旦继承了父类，它就会继承父类的所有非私有属性和方法，但是构造方法不能被继承的。
  * 	Object是所有类的超类。
  * 	2.封装：实现封装的关键在于不能让其他对象直接访问本对象的实例域。
  * 	仅能通过对象的方法来访问对象数据进行交互。
  * 	封装是将数据和行为组合在一个类中。
  * 	封装给对象赋予了“黑盒”特征，这是提高重用性和我可靠性的关键。
  * 	这就意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，
  * 	其他对象就不会知道或介意所发生的变化。
  * 	3.多态：
  * 	1语义：一个事物的多种状态
  * 	2编码：一个方法的多种实现
  * 	3设计：将做什么和怎么做分开
  * 	多态的目的：解耦合
  * 	多态是实现开闭原则的重要手段。
  * 7.对象的3个主要特性：
  * 	1.对象的行为：用可调用的方法定义的。
  * 	2.对象的状态：每个对象都保存着描述当前特征的信息。
  * 	对象的状态的改变必须通过调用方法来实现。
  * 	但是，对象的状态并不能改变对象状态。每个对象都有一个唯一的身份。
  * 	3.对象的标识：需要注意：作为一个类的对象，每个对象的标识永远是不同的，状态常常也存在着差异。
  * 	这些关键的特性在彼此之间相互影响着。
  * 
  * 8.识别类
  * 	1.识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
  * 	2.在创建类的时候，哪些名词和动词完全取决于个人的开发经验。
  * 
  * 9.类之间的关系：
  * 	1.依赖（uses-a）：如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。
  * 	应该尽可能地将相互依赖的类减至最少（让类之间的耦合度最小）。
  * 	2.聚合（has-a）：比如类A的对象包含B的对象。
  * 	3.继承（is-a）：一种用于表示特殊与一般的关系的。
  */
public class OOPTest extends A{
	public OOPTest(){
		System.out.println("oopTest");
	}
	public static void main(String[] args) {
		test();
		test1();
	}
	/*
	 * 如果父类中没有无参构造方法，则子类必须显示调用（super方法）父类其他的构造方法去创建父类。
	 */
	private static void test1() {
		OOPT o=new OOPT(11);
		//B11
		//oopTest
	}
	/*
	 * 当子类对象被创建时候，默认情况下，子类会调用其父类的无参构造方法，先创建它的父类对象。
	 * 如果父类中没有无参构造方法，则子类必须显示调用（super方法）父类其他的构造方法去创建父类。
	 */
	private static void test() {
		OOPTest o=new OOPTest();  
		//输出   A     
		//oopTest	
	}
}
class OOPT extends B{
	public OOPT(int testData){
		//super--代表父类对象
		super(testData);
		System.out.println("oopTest");
	}
}
class A{
	public A(){
		System.out.println("A");
	}
}
class B{
	int testData;
	public B(int testData){
		this.testData=testData;
		System.out.println("B"+testData);
	}
}
